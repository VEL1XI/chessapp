<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game - Multiplayer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <link rel="stylesheet" href="/static/styles.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            width: 100%;
        }

        .auth-screen, .lobby-screen, .game-screen, .profile-screen {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .hidden {
            display: none !important;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        h2 {
            color: #333;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
        }

        input[type="text"],
        input[type="password"],
        input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="password"]:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            margin-top: 10px;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .lobby-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .lobby-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 25px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            text-align: center;
        }

        .lobby-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.2);
        }

        .lobby-card.in-game {
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
        }

        .lobby-card h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .lobby-card p {
            color: #666;
            font-size: 14px;
        }

        .game-container {
            display: grid;
            grid-template-columns: 1fr 600px 1fr;
            gap: 30px;
            align-items: start;
        }

        .player-info {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
        }

        .player-card {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .profile-pic {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin-right: 15px;
            border: 3px solid #667eea;
            object-fit: cover;
        }

        .player-details h3 {
            color: #333;
            margin-bottom: 5px;
        }

        .player-details p {
            color: #666;
            font-size: 14px;
        }

        .stats {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-label {
            color: #666;
            font-weight: 600;
        }

        .stat-value {
            color: #667eea;
            font-weight: bold;
        }

        #chessboard {
            width: 600px;
            margin: 0 auto;
        }

        .game-controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .game-status {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .turn-indicator {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .game-result {
            font-size: 24px;
            font-weight: bold;
            color: #28a745;
            margin-top: 10px;
        }

        .user-profile-badge {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: transform 0.2s;
            z-index: 1000;
        }

        .user-profile-badge:hover {
            transform: translateY(-2px);
        }

        .user-profile-badge img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #667eea;
            object-fit: cover;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #f5c6cb;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #c3e6cb;
        }

        /* Profile Page Styles */
        .profile-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .profile-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            color: white;
        }

        .profile-pic-large {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 5px solid white;
            margin: 0 auto 20px;
            display: block;
            object-fit: cover;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .profile-name {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .profile-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: transform 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-card-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }

        .stat-card-label {
            color: #666;
            font-weight: 600;
        }

        .profile-edit-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
        }

        .upload-zone {
            border: 3px dashed #ddd;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
            margin-bottom: 20px;
        }

        .upload-zone:hover {
            border-color: #667eea;
            background: #f8f9fa;
        }

        .upload-zone.dragover {
            border-color: #667eea;
            background: #e7f0ff;
        }

        /* Moved inline styles into CSS class to avoid inline style usage */
        .upload-info {
            font-size: 14px;
            color: #999;
            margin-top: 10px;
        }

        .preview-image {
            max-width: 200px;
            max-height: 200px;
            border-radius: 15px;
            margin: 20px auto;
            display: block;
            object-fit: cover;
        }

        .hidden-input {
            display: none;
        }

        .winrate {
            font-size: 1.2em;
            color: #28a745;
            font-weight: bold;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .button-group button {
            width: auto;
            flex: 1;
        }

        .highlight-square {
            box-shadow: inset 0 0 3px 3px yellow;
        }

        .highlight-move {
            background: radial-gradient(circle, rgba(0, 255, 0, 0.3) 20%, transparent 20%);
            background-size: 100% 100%;
        }

        .highlight-capture {
            background: radial-gradient(circle, rgba(255, 0, 0, 0.4) 20%, transparent 20%);
            background-size: 100% 100%;
        }

        .check-square {
            box-shadow: inset 0 0 10px 5px rgba(255, 0, 0, 0.7);
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .separator {
            margin: 30px 0;
            border: none;
            border-top: 2px solid #ddd;
        }

        @media (max-width: 1200px) {
            .game-container {
                grid-template-columns: 1fr;
            }
            
            #chessboard {
                width: 100%;
                max-width: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Auth Screen -->
        <div class="auth-screen hidden" id="authScreen">
            <h1>‚ôüÔ∏è Chess Multiplayer</h1>
            
            <div id="loginForm">
                <h2>Login</h2>
                <div id="loginError" class="error-message hidden"></div>
                <div class="form-group">
                    <label>Username</label>
                    <input type="text" id="loginUsername" placeholder="Masukkan username">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="loginPassword" placeholder="Masukkan password">
                </div>
                <button onclick="login()">Login</button>
                <button class="btn-secondary" onclick="showRegister()">Belum punya akun? Daftar</button>
            </div>

            <div id="registerForm" class="hidden">
                <h2>Register</h2>
                <div id="registerError" class="error-message hidden"></div>
                <div class="form-group">
                    <label>Username</label>
                    <input type="text" id="registerUsername" placeholder="Masukkan username">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="registerPassword" placeholder="Masukkan password">
                </div>
                <button onclick="register()">Daftar</button>
                <button class="btn-secondary" onclick="showLogin()">Sudah punya akun? Login</button>
            </div>
        </div>

        <!-- Lobby Screen -->
        <div class="lobby-screen hidden" id="lobbyScreen">
            <h1>‚ôüÔ∏è Pilih Lobby</h1>
            <div class="user-profile-badge" onclick="showProfile()">
                <img id="userBadgeAvatar" src="/uploads/default-avatar.png" alt="Profile">
                <div>
                    <strong id="userBadgeName"></strong>
                    <p id="userBadgeStats"></p>
                </div>
            </div>
            <div class="lobby-grid" id="lobbyGrid"></div>
            <button class="btn-secondary" onclick="logout()">Logout</button>
        </div>

        <!-- Profile Screen -->
        <div class="profile-screen hidden" id="profileScreen">
            <div class="profile-container">
                <div class="profile-header">
                    <img class="profile-pic-large" id="profilePicLarge" src="/uploads/default-avatar.png" alt="Profile">
                    <h2 class="profile-name" id="profileName">Username</h2>
                    <p class="winrate" id="winRate">Win Rate: 0%</p>
                </div>

                <div class="profile-stats-grid">
                    <div class="stat-card">
                        <div class="stat-card-value" id="totalMatches">0</div>
                        <div class="stat-card-label">Total Match</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-value" id="totalWins">0</div>
                        <div class="stat-card-label">Menang</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-value" id="totalLosses">0</div>
                        <div class="stat-card-label">Kalah</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-value" id="totalDraws">0</div>
                        <div class="stat-card-label">Seri</div>
                    </div>
                </div>

                <div class="profile-edit-section">
                    <h2>Edit Profil</h2>
                    
                    <div class="form-group">
                        <input type="text" id="editUsername" placeholder="Username baru">
                        <button class="btn-success btn-update-username" onclick="updateUsername()">‚úèÔ∏è Update Username</button>
                    </div>
                    </div>
                            <p class="upload-info">Format: JPG, PNG (Max 5MB)</p>
                    <hr class="separator">

                    <div class="form-group">
                        <label>Upload Foto Profil</label>
                        <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()">
                            <p>üì∑ Klik atau drag & drop untuk upload foto</p>
                            <p class="upload-info">Format: JPG, PNG (Max 5MB)</p>
                        </div>
                        <input type="file" id="fileInput" accept="image/*" class="hidden-input" onchange="handleFileSelect(event)">
                        <img id="previewImage" class="preview-image hidden" src="" alt="Preview">
                        <button class="btn-success hidden" id="uploadPfpBtn" onclick="updateProfilePic()">üì∑ Upload Foto Profil</button>
                    </div>

                    <div id="profileMessage" class="hidden"></div>

                    <button class="btn-secondary" onclick="backToLobby()">‚Üê Kembali ke Lobby</button>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div class="game-screen hidden" id="gameScreen">
            <div class="game-container">
                <div class="player-info">
                    <h2>Player Info</h2>
                    <div id="whitePlayerInfo"></div>
                    <div id="blackPlayerInfo"></div>
                </div>

                <div>
                    <div class="game-status">
                        <div class="turn-indicator" id="turnIndicator">Menunggu pemain...</div>
                        <div class="game-result hidden" id="gameResult"></div>
                    </div>
                    <div id="chessboard"></div>
                    <div class="game-controls">
                        <button class="btn-secondary" id="offerDrawBtn" onclick="offerDraw()">ü§ù Tawarkan Seri</button>
                        <button class="btn-danger" id="forfeitBtn" onclick="forfeitGame()">üö© Menyerah</button>
                        <button class="btn-danger" onclick="leaveLobby()">Keluar Lobby</button>
                        <button class="btn-success hidden" id="rematchBtn" onclick="requestRematch()">Rematch</button>
                    </div>
                </div>

                <div class="player-info">
                    <h2>Statistik Saya</h2>
                    <div class="stats" id="myStats"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
    
    <script>
        const API_URL = 'http://localhost:8080/api';
        const WS_URL = 'ws://localhost:8080/api';
        
        let currentUser = null;
        let currentLobby = null;
        let ws = null;
        let board = null;
        let game = new Chess();
        let playerColor = null;
        let selectedFile = null;
        let lobbyInterval = null;
        let gameOverReported = false;
        let gameResultShown = false;

        // Auth Functions
        async function login() {
            const username = document.getElementById('loginUsername').value;
            const password = document.getElementById('loginPassword').value;
            const errorDiv = document.getElementById('loginError');

            try {
                const response = await fetch(`${API_URL}/login`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({username, password})
                });

                if (!response.ok) {
                    throw new Error('Login gagal');
                }

                currentUser = await response.json();
                localStorage.setItem('user', JSON.stringify(currentUser));
                showLobbyScreen();
            } catch (error) {
                errorDiv.textContent = error.message;
                errorDiv.classList.remove('hidden');
            }
        }

        async function register() {
            const username = document.getElementById('registerUsername').value;
            const password = document.getElementById('registerPassword').value;
            const errorDiv = document.getElementById('registerError');

            try {
                const response = await fetch(`${API_URL}/register`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({username, password})
                });

                if (!response.ok) {
                    throw new Error('Username sudah digunakan');
                }

                currentUser = await response.json();
                localStorage.setItem('user', JSON.stringify(currentUser));
                showLobbyScreen();
            } catch (error) {
                errorDiv.textContent = error.message;
                errorDiv.classList.remove('hidden');
            }
        }

        function showRegister() {
            document.getElementById('loginForm').classList.add('hidden');
            document.getElementById('registerForm').classList.remove('hidden');
        }

        function showLogin() {
            document.getElementById('registerForm').classList.add('hidden');
            document.getElementById('loginForm').classList.remove('hidden');
        }

        function logout() {
            localStorage.clear();
            currentUser = null;
            if (ws) ws.close();
            if (lobbyInterval) clearInterval(lobbyInterval);
            location.reload();
        }

        // Lobby Functions
        async function showLobbyScreen() {
            // Hide all screens first
            document.getElementById('authScreen').classList.add('hidden');
            document.getElementById('profileScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('lobbyScreen').classList.remove('hidden');
            
            // Save current screen state (only if not in game)
            const currentScreen = localStorage.getItem('currentScreen');
            if (currentScreen !== 'game') {
                localStorage.setItem('currentScreen', 'lobby');
            }
            
            // Only clear lobby if explicitly leaving game
            if (currentScreen === 'lobby' || !currentScreen) {
                localStorage.removeItem('currentLobby');
            }
            
            updateUserBadge();
            await loadLobbies();
            
            // Clear existing interval and set new one
            if (lobbyInterval) clearInterval(lobbyInterval);
            lobbyInterval = setInterval(loadLobbies, 3000);
        }

        function updateUserBadge() {
            const avatarUrl = currentUser.profile_pic || '/uploads/default-avatar.png';
            document.getElementById('userBadgeAvatar').src = avatarUrl;
            document.getElementById('userBadgeAvatar').onerror = function() {
                this.src = '/uploads/default-avatar.png';
            };
            document.getElementById('userBadgeName').textContent = currentUser.username;
            document.getElementById('userBadgeStats').textContent = 
                `${currentUser.total_wins}W - ${currentUser.total_losses}L - ${currentUser.total_draws}D`;
        }

        async function loadLobbies() {
            try {
                const response = await fetch(`${API_URL}/lobbies`);
                if (!response.ok) {
                    throw new Error('Failed to load lobbies');
                }
                const lobbies = await response.json();
                
                const grid = document.getElementById('lobbyGrid');
                
                if (!lobbies || lobbies.length === 0) {
                    grid.innerHTML = '<p style="text-align: center; color: #666;">Tidak ada lobby tersedia</p>';
                    return;
                }
                
                grid.innerHTML = lobbies.map(lobby => `
                    <div class="lobby-card ${lobby.inGame ? 'in-game' : ''}" onclick="joinLobby(${lobby.id})">
                        <h3>Lobby ${lobby.id}</h3>
                        <p>${lobby.playerCount}/2 pemain</p>
                        <p>${lobby.inGame ? 'üéÆ Sedang bermain' : '‚ö™ Tersedia'}</p>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error loading lobbies:', error);
                const grid = document.getElementById('lobbyGrid');
                grid.innerHTML = '<p style="text-align: center; color: #dc3545;">Gagal memuat lobby. Pastikan server berjalan.</p>';
            }
        }

        // Profile Functions
        async function showProfile() {
            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('authScreen').classList.add('hidden');
            document.getElementById('profileScreen').classList.remove('hidden');
            
            // Save current screen state
            localStorage.setItem('currentScreen', 'profile');
            
            // Clear lobby interval when in profile
            if (lobbyInterval) clearInterval(lobbyInterval);
            
            await loadUserProfile();
        }

        async function loadUserProfile() {
            try {
                const response = await fetch(`${API_URL}/user/${currentUser.id}`);
                const user = await response.json();
                
                currentUser = user;
                localStorage.setItem('user', JSON.stringify(currentUser));

                document.getElementById('profilePicLarge').src = user.profile_pic || '/uploads/default-avatar.png';
                document.getElementById('profilePicLarge').onerror = function() {
                    this.src = '/uploads/default-avatar.png';
                };
                document.getElementById('profileName').textContent = user.username;
                document.getElementById('editUsername').value = user.username;
                
                document.getElementById('totalMatches').textContent = user.total_matches;
                document.getElementById('totalWins').textContent = user.total_wins;
                document.getElementById('totalLosses').textContent = user.total_losses;
                document.getElementById('totalDraws').textContent = user.total_draws;
                
                const winRate = user.total_matches > 0 
                    ? ((user.total_wins / user.total_matches) * 100).toFixed(1)
                    : 0;
                document.getElementById('winRate').textContent = `Win Rate: ${winRate}%`;
            } catch (error) {
                console.error('Error loading profile:', error);
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                if (file.size > 5 * 1024 * 1024) {
                    showProfileMessage('File terlalu besar! Maksimal 5MB', 'error');
                    return;
                }
                
                selectedFile = file;
                const reader = new FileReader();
                reader.onload = function(e) {
                    const preview = document.getElementById('previewImage');
                    preview.src = e.target.result;
                    preview.classList.remove('hidden');
                    document.getElementById('uploadPfpBtn').classList.remove('hidden');
                };
                reader.readAsDataURL(file);
            }
        }

        // Drag and drop
        const uploadZone = document.getElementById('uploadZone');
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });
        
        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });
        
        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                document.getElementById('fileInput').files = dataTransfer.files;
                handleFileSelect({target: {files: [file]}});
            }
        });

        // Update Username only
        async function updateUsername() {
            const newUsername = document.getElementById('editUsername').value.trim();
            
            if (!newUsername) {
                showProfileMessage('‚ö†Ô∏è Username tidak boleh kosong', 'error');
                return;
            }

            if (newUsername === currentUser.username) {
                showProfileMessage('‚ö†Ô∏è Username sama dengan sebelumnya', 'error');
                return;
            }
            
            try {
                const updateResponse = await fetch(`${API_URL}/user/${currentUser.id}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ username: newUsername })
                });
                
                if (!updateResponse.ok) {
                    const errorData = await updateResponse.json();
                    throw new Error(errorData.error || 'Gagal update username');
                }
                
                const updatedUser = await updateResponse.json();
                currentUser = updatedUser;
                localStorage.setItem('user', JSON.stringify(currentUser));
                
                showProfileMessage('‚úÖ Username berhasil diupdate!', 'success');
                
                setTimeout(() => {
                    loadUserProfile();
                }, 1000);
            } catch (error) {
                console.error('Update username error:', error);
                showProfileMessage('‚ùå ' + error.message, 'error');
            }
        }

        // Update Profile Picture only
        async function updateProfilePic() {
            if (!selectedFile) {
                showProfileMessage('‚ö†Ô∏è Pilih foto terlebih dahulu', 'error');
                return;
            }
            
            try {
                // Upload file first
                const formData = new FormData();
                formData.append('profile_pic', selectedFile);
                formData.append('user_id', currentUser.id);
                
                const uploadResponse = await fetch(`${API_URL}/upload-profile-pic`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    const errorData = await uploadResponse.json();
                    throw new Error(errorData.error || 'Gagal upload foto');
                }
                
                const result = await uploadResponse.json();
                const profilePicUrl = result.url;
                
                // Update profile with new picture URL
                const updateResponse = await fetch(`${API_URL}/user/${currentUser.id}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ profile_pic: profilePicUrl })
                });
                
                if (!updateResponse.ok) {
                    const errorData = await updateResponse.json();
                    throw new Error(errorData.error || 'Gagal update profil');
                }
                
                const updatedUser = await updateResponse.json();
                currentUser = updatedUser;
                localStorage.setItem('user', JSON.stringify(currentUser));
                
                showProfileMessage('‚úÖ Foto profil berhasil diupdate!', 'success');
                
                selectedFile = null;
                document.getElementById('previewImage').classList.add('hidden');
                document.getElementById('uploadPfpBtn').classList.add('hidden');
                document.getElementById('fileInput').value = '';
                
                setTimeout(() => {
                    loadUserProfile();
                }, 1000);
            } catch (error) {
                console.error('Update profile pic error:', error);
                showProfileMessage('‚ùå ' + error.message, 'error');
            }
        }

        function showProfileMessage(message, type) {
            const msgDiv = document.getElementById('profileMessage');
            msgDiv.className = type === 'success' ? 'success-message' : 'error-message';
            msgDiv.textContent = message;
            msgDiv.classList.remove('hidden');
            
            setTimeout(() => {
                msgDiv.classList.add('hidden');
            }, 3000);
        }

        function backToLobby() {
            document.getElementById('profileScreen').classList.add('hidden');
            showLobbyScreen();
        }

        function joinLobby(lobbyId) {
            currentLobby = lobbyId;
            
            // Save state IMMEDIATELY before connecting
            localStorage.setItem('currentLobby', lobbyId);
            localStorage.setItem('currentScreen', 'game');
            
            // Reset game state flags
            gameOverReported = false;
            gameResultShown = false;
            
            console.log('Joining lobby', lobbyId);
            
            // Clear lobby interval
            if (lobbyInterval) clearInterval(lobbyInterval);
            
            connectWebSocket(lobbyId);
            showGameScreen();
        }

        function connectWebSocket(lobbyId) {
            ws = new WebSocket(`${WS_URL}/lobby/${lobbyId}/ws`);
            
            ws.onopen = () => {
                ws.send(JSON.stringify({
                    type: 'join',
                    payload: {
                        username: currentUser.username,
                        userId: currentUser.id
                    }
                }));
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                handleWebSocketMessage(msg);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                console.log('WebSocket closed');
            };
        }

        function handleWebSocketMessage(msg) {
            switch(msg.type) {
                case 'playerJoined':
                    if (msg.payload.username === currentUser.username) {
                        playerColor = msg.payload.color;
                        initBoard();
                    }
                    
                    // Restore game state from server
                    if (msg.payload.game) {
                        const gameData = msg.payload.game;
                        
                        // Reset game and load from moves history
                        game.reset();
                        
                        if (gameData.moves && gameData.moves.length > 0) {
                            // Replay all moves to reconstruct board state
                            for (let i = 0; i < gameData.moves.length; i++) {
                                const moveUCI = gameData.moves[i];
                                // Convert UCI to standard notation for chess.js
                                const from = moveUCI.substring(0, 2);
                                const to = moveUCI.substring(2, 4);
                                const promotion = moveUCI.length > 4 ? moveUCI.substring(4, 5) : '';
                                
                                const moveObj = {from: from, to: to};
                                if (promotion) {
                                    moveObj.promotion = promotion;
                                }
                                
                                const result = game.move(moveObj);
                                if (!result) {
                                    console.warn("Failed to replay move: " + moveUCI);
                                }
                            }
                        }
                        
                        // Verify against server FEN
                        if (gameData.fen && game.fen() !== gameData.fen) {
                            console.warn("FEN mismatch after replay, loading server FEN directly");
                            game.load(gameData.fen);
                        }
                        
                        board.position(game.fen());
                        
                        // If game has ended, show result
                        if (gameData.gameEnded && !gameResultShown) {
                            gameResultShown = true;
                            gameOverReported = true;
                            // Server will send gameOver message, but in case we reconnected after game end, check locally
                            if (game.game_over()) {
                                let message = '';
                                if (game.in_checkmate()) {
                                    const winner = game.turn() === 'w' ? 'black' : 'white';
                                    message = winner === playerColor ? 'üéâ CHECKMATE! Anda Menang!' : 'üíî CHECKMATE! Anda Kalah!';
                                } else if (game.in_draw()) {
                                    message = 'ü§ù Permainan Seri!';
                                }
                                if (message) {
                                    showGameOverNotification(message);
                                }
                            }
                        }
                    }
                    
                    updatePlayerInfo(msg.payload.game);
                    updateTurnIndicator(msg.payload.game);
                    break;

                case 'gameState':
                    // Handle full game state on reconnect
                    if (msg.payload.game) {
                        const gameData = msg.payload.game;
                        
                        // Reset and replay moves to reconstruct state
                        game.reset();
                        
                        if (gameData.moves && gameData.moves.length > 0) {
                            // Replay all moves to reconstruct board state
                            for (let i = 0; i < gameData.moves.length; i++) {
                                const moveUCI = gameData.moves[i];
                                // Convert UCI to standard notation for chess.js
                                const from = moveUCI.substring(0, 2);
                                const to = moveUCI.substring(2, 4);
                                const promotion = moveUCI.length > 4 ? moveUCI.substring(4, 5) : '';
                                
                                const moveObj = {from: from, to: to};
                                if (promotion) {
                                    moveObj.promotion = promotion;
                                }
                                
                                const result = game.move(moveObj);
                                if (!result) {
                                    console.warn("Failed to replay move: " + moveUCI);
                                }
                            }
                        }
                        
                        // Verify against server FEN
                        if (gameData.fen && game.fen() !== gameData.fen) {
                            console.warn("FEN mismatch after replay, loading server FEN directly");
                            game.load(gameData.fen);
                        }
                        
                        // Determine player color
                        if (gameData.white_player === currentUser.username) {
                            playerColor = 'white';
                        } else if (gameData.black_player === currentUser.username) {
                            playerColor = 'black';
                        }
                        
                        if (!board) {
                            initBoard();
                        } else {
                            board.position(game.fen());
                        }
                        
                        // If game has ended, show result
                        if (gameData.gameEnded && !gameResultShown) {
                            gameResultShown = true;
                            gameOverReported = true;
                            if (game.game_over()) {
                                let message = '';
                                if (game.in_checkmate()) {
                                    const winner = game.turn() === 'w' ? 'black' : 'white';
                                    message = winner === playerColor ? 'üéâ CHECKMATE! Anda Menang!' : 'üíî CHECKMATE! Anda Kalah!';
                                } else if (game.in_draw()) {
                                    message = 'ü§ù Permainan Seri!';
                                }
                                if (message) {
                                    showGameOverNotification(message);
                                }
                            }
                        }
                        
                        updatePlayerInfo(gameData);
                        updateTurnIndicator(gameData);
                    }
                    break;

                case 'move':
                    game.move({
                        from: msg.payload.from,
                        to: msg.payload.to,
                        promotion: msg.payload.promotion || 'q'
                    });
                    board.position(game.fen());
                    
                    // Update turn indicator with new game state
                    updateTurnIndicator(msg.payload.game);
                    
                    // Update check highlight
                    $('#chessboard .square-55d63').removeClass('check-square');
                    if (game.in_check()) {
                        const color = game.turn();
                        const kingSquare = findKingSquare(color);
                        if (kingSquare) {
                            $('#chessboard .square-' + kingSquare).addClass('check-square');
                        }
                    }
                    
                    checkGameOver();
                    break;

                case 'moveAccepted':
                    // Our move was accepted by the server - update FEN from server to stay in sync
                    if (msg.payload.game && msg.payload.game.fen) {
                        game.load(msg.payload.game.fen);
                        board.position(game.fen());
                        updateTurnIndicator(msg.payload.game);
                        // Check for game over now that move is confirmed by server
                        checkGameOver();
                    }
                    break;

                case 'gameOver':
                    displayGameResult(msg.payload);
                    break;

                case 'rematch':
                    resetGame(msg.payload.game);
                    break;

                case 'offerDraw':
                    showDrawOfferDialog(msg.payload.from);
                    break;

                case 'forfeit':
                    displayGameResult(msg.payload);
                    break;

                case 'playerLeft':
                    // Don't automatically leave - just show notification
                    const leftMessage = `‚ö†Ô∏è ${msg.payload.username} telah keluar dari permainan`;
                    showCheckNotification(leftMessage);
                    
                    // Optional: Show reconnect waiting message
                    document.getElementById('turnIndicator').innerHTML = 
                        `Menunggu ${msg.payload.username} kembali...`;
                    break;

                case 'moveRejected':
                    // Server rejected the move - revert the move locally
                    const reason = msg.payload.reason || 'unknown';
                    console.log("‚ö†Ô∏è Move rejected: " + reason);
                    
                    // Undo the move from our local game state
                    game.undo();
                    board.position(game.fen());
                    
                    // Show error notification to player
                    showCheckNotification(`‚ùå Gerakan ditolak: ${reason}`);
                    break;
            }
        }

        function showDrawOfferDialog(from) {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 10001;
                display: flex;
                justify-content: center;
                align-items: center;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                box-shadow: 0 20px 60px rgba(0,0,0,0.5);
                max-width: 400px;
            `;

            dialog.innerHTML = `
                <h3 style="margin-bottom: 20px; color: #333;">Penawaran Seri dari ${from}</h3>
                <p style="margin-bottom: 30px; color: #666;">Apakah anda ingin menerima penawaran seri?</p>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button onclick="acceptDraw()" style="flex: 1; padding: 12px; font-size: 16px; background: #28a745; color: white; border: none; border-radius: 10px; cursor: pointer;">
                        ‚úì Terima
                    </button>
                    <button onclick="declineDraw()" style="flex: 1; padding: 12px; font-size: 16px; background: #dc3545; color: white; border: none; border-radius: 10px; cursor: pointer;">
                        ‚úó Tolak
                    </button>
                </div>
            `;

            overlay.appendChild(dialog);
            overlay.id = 'drawOfferOverlay';
            document.body.appendChild(overlay);
        }

        function acceptDraw() {
            const overlay = document.getElementById('drawOfferOverlay');
            if (overlay) overlay.remove();

            ws.send(JSON.stringify({
                type: 'gameOver',
                payload: {
                    winner: 'draw',
                    result: 'draw'
                }
            }));
        }

        function declineDraw() {
            const overlay = document.getElementById('drawOfferOverlay');
            if (overlay) overlay.remove();

            showCheckNotification('‚öñÔ∏è Penawaran seri ditolak');
        }

        // Game Functions
        function showGameScreen() {
            document.getElementById('authScreen').classList.add('hidden');
            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('profileScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            
            // Make sure state is saved
            if (currentLobby) {
                localStorage.setItem('currentLobby', currentLobby);
                localStorage.setItem('currentScreen', 'game');
            }
            
            loadMyStats();
        }

        function initBoard() {
            const config = {
                draggable: true,
                position: 'start',
                onDragStart: onDragStart,
                onDrop: onDrop,
                onSnapEnd: onSnapEnd,
                onMouseoutSquare: onMouseoutSquare,
                onMouseoverSquare: onMouseoverSquare,
                orientation: playerColor === 'white' ? 'white' : 'black',
                pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
            };

            board = Chessboard('chessboard', config);
            game = new Chess();
        }

        function removeHighlights() {
            $('#chessboard .square-55d63').removeClass('highlight-square highlight-move highlight-capture');
        }

        function highlightSquare(square) {
            const squareEl = $('#chessboard .square-' + square);
            squareEl.addClass('highlight-square');
        }

        function onMouseoverSquare(square, piece) {
            // Get list of possible moves for this square
            const moves = game.moves({
                square: square,
                verbose: true
            });

            // Exit if no moves available
            if (moves.length === 0) return;

            // Highlight the square they moused over
            highlightSquare(square);

            // Highlight the possible squares for this piece
            for (let i = 0; i < moves.length; i++) {
                const move = moves[i];
                const squareEl = $('#chessboard .square-' + move.to);
                
                if (move.captured) {
                    squareEl.addClass('highlight-capture');
                } else {
                    squareEl.addClass('highlight-move');
                }
            }
        }

        function onMouseoutSquare(square, piece) {
            removeHighlights();
        }

        function onDragStart(source, piece, position, orientation) {
            // Remove highlights when dragging starts
            removeHighlights();
            
            if (game.game_over()) return false;
            if ((playerColor === 'white' && piece.search(/^b/) !== -1) ||
                (playerColor === 'black' && piece.search(/^w/) !== -1)) {
                return false;
            }
            if ((game.turn() === 'w' && playerColor !== 'white') ||
                (game.turn() === 'b' && playerColor !== 'black')) {
                return false;
            }
            
            // Highlight legal moves while dragging
            onMouseoverSquare(source, piece);
        }

        function onDrop(source, target) {
            removeHighlights();
            
            // Check if it's a pawn promotion
            const piece = game.get(source);
            
            // First, try move WITHOUT temporary promotion to check if it's actually a promotion move
            const testMove = game.move({
                from: source,
                to: target
            }, {sloppy: false});

            if (testMove === null) {
                return 'snapback';
            }

            // Check if pawn reached the last rank (promotion)
            const targetRank = target.charCodeAt(1) - '1'.charCodeAt(0) + 1;
            const isPawnPromotion = piece && piece.type === 'p' && (targetRank === 8 || targetRank === 1);

            if (isPawnPromotion) {
                // Undo the test move
                game.undo();
                
                // Show promotion dialog (will handle move application)
                showPromotionDialog(source, target);
                return;
            }

            // Send move to server
            // Note: onSnapEnd() will be called by chessboard.js to update the board visually
            ws.send(JSON.stringify({
                type: 'move',
                payload: {
                    from: source,
                    to: target,
                    promotion: '',
                    fen: game.fen()
                }
            }));

            // Update turn indicator immediately after move
            updateTurnIndicator({ turn: game.turn(), white_player: playerInfo.white_player, black_player: playerInfo.black_player });

            // Don't check game over yet - wait for server to confirm the move via moveAccepted
        }

        function showPromotionDialog(source, target) {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 10001;
                display: flex;
                justify-content: center;
                align-items: center;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            `;

            dialog.innerHTML = `
                <h3 style="margin-bottom: 20px; color: #333;">Pilih Promosi Pion</h3>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button onclick="promoteAndMove('${source}', '${target}', 'q')" style="padding: 15px 25px; font-size: 24px; background: #667eea; color: white; border: none; border-radius: 10px; cursor: pointer;">
                        ‚ôï Ratu
                    </button>
                    <button onclick="promoteAndMove('${source}', '${target}', 'r')" style="padding: 15px 25px; font-size: 24px; background: #667eea; color: white; border: none; border-radius: 10px; cursor: pointer;">
                        ‚ôñ Benteng
                    </button>
                    <button onclick="promoteAndMove('${source}', '${target}', 'b')" style="padding: 15px 25px; font-size: 24px; background: #667eea; color: white; border: none; border-radius: 10px; cursor: pointer;">
                        ‚ôó Gajah
                    </button>
                    <button onclick="promoteAndMove('${source}', '${target}', 'n')" style="padding: 15px 25px; font-size: 24px; background: #667eea; color: white; border: none; border-radius: 10px; cursor: pointer;">
                        ‚ôò Kuda
                    </button>
                </div>
            `;

            overlay.appendChild(dialog);
            overlay.id = 'promotionOverlay';
            document.body.appendChild(overlay);
        }

        function promoteAndMove(source, target, promotion) {
            // Remove overlay
            const overlay = document.getElementById('promotionOverlay');
            if (overlay) overlay.remove();

            const move = game.move({
                from: source,
                to: target,
                promotion: promotion
            });

            if (move === null) {
                alert('Invalid move!');
                return;
            }

            board.position(game.fen());

            ws.send(JSON.stringify({
                type: 'move',
                payload: {
                    from: source,
                    to: target,
                    promotion: promotion,
                    fen: game.fen()
                }
            }));

            // Update turn indicator immediately after move
            updateTurnIndicator({ turn: game.turn(), white_player: playerInfo.white_player, black_player: playerInfo.black_player });

            // Don't check game over yet - wait for server to confirm the move via moveAccepted
        }

        function onSnapEnd() {
            board.position(game.fen());
            
            // Remove all check highlights first
            $('#chessboard .square-55d63').removeClass('check-square');
            
            // Highlight king if in check
            if (game.in_check()) {
                const color = game.turn();
                const kingSquare = findKingSquare(color);
                if (kingSquare) {
                    $('#chessboard .square-' + kingSquare).addClass('check-square');
                }
            }
        }

        function findKingSquare(color) {
            const squares = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            for (let i = 0; i < squares.length; i++) {
                for (let j = 1; j <= 8; j++) {
                    const square = squares[i] + j;
                    const piece = game.get(square);
                    if (piece && piece.type === 'k' && piece.color === color) {
                        return square;
                    }
                }
            }
            return null;
        }

        function checkGameOver() {
            if (game.game_over()) {
                // Prevent duplicate game-over reporting
                if (gameOverReported) {
                    return;
                }
                gameOverReported = true;

                let winner = 'draw';
                let result = 'draw';
                let message = '';

                if (game.in_checkmate()) {
                    winner = game.turn() === 'w' ? 'black' : 'white';
                    result = winner;
                    
                    if (winner === playerColor) {
                        message = 'üéâ CHECKMATE! Anda Menang!';
                    } else {
                        message = 'üíî CHECKMATE! Anda Kalah!';
                    }
                } else if (game.in_draw()) {
                    message = 'ü§ù Permainan Seri!';
                    if (game.in_stalemate()) {
                        message += ' (Stalemate)';
                    } else if (game.in_threefold_repetition()) {
                        message += ' (Threefold Repetition)';
                    } else if (game.insufficient_material()) {
                        message += ' (Insufficient Material)';
                    }
                }

                // Show local notification first
                showGameOverNotification(message);

                ws.send(JSON.stringify({
                    type: 'gameOver',
                    payload: {winner, result}
                }));
            } else if (game.in_check()) {
                // Show check notification
                const color = game.turn() === 'w' ? 'Putih' : 'Hitam';
                showCheckNotification(`‚ö†Ô∏è SKAK! ${color} dalam ancaman!`);
            }
        }

        function showCheckNotification(message) {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 152, 0, 0.95);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
                animation: pulse 0.5s ease-in-out;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            // Remove after 2 seconds
            setTimeout(() => {
                notification.remove();
            }, 2000);
        }

        function showGameOverNotification(message) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
            `;

            const notification = document.createElement('div');
            notification.style.cssText = `
                background: white;
                padding: 40px;
                border-radius: 20px;
                text-align: center;
                box-shadow: 0 20px 60px rgba(0,0,0,0.5);
                max-width: 500px;
            `;

            notification.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 20px;">${message.includes('Menang') ? 'üéâ' : message.includes('Kalah') ? 'üò¢' : 'ü§ù'}</div>
                <div style="font-size: 28px; font-weight: bold; color: #333; margin-bottom: 30px;">${message}</div>
                <div style="display: flex; gap: 15px;">
                    <button onclick="requestRematch()" style="flex: 1; padding: 15px; font-size: 18px; background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border: none; border-radius: 10px; cursor: pointer;">
                        üîÑ Rematch
                    </button>
                    <button onclick="leaveLobby()" style="flex: 1; padding: 15px; font-size: 18px; background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white; border: none; border-radius: 10px; cursor: pointer;">
                        üö™ Keluar
                    </button>
                </div>
            `;

            overlay.appendChild(notification);
            overlay.id = 'gameOverOverlay';
            document.body.appendChild(overlay);
        }

        async function updatePlayerInfo(gameData) {
            const whitePlayer = gameData && gameData.white_player ? gameData.white_player : '';
            const blackPlayer = gameData && gameData.black_player ? gameData.black_player : '';
            
            let whitePfp = '/uploads/default-avatar.png';
            let blackPfp = '/uploads/default-avatar.png';
            
            // Get profile pictures from API
            if (whitePlayer) {
                try {
                    const response = await fetch(`${API_URL}/user-by-username/${whitePlayer}`);
                    if (response.ok) {
                        const user = await response.json();
                        whitePfp = user.profile_pic || whitePfp;
                    }
                } catch (e) {
                    console.log('Could not fetch white player pfp');
                }
            }
            
            if (blackPlayer) {
                try {
                    const response = await fetch(`${API_URL}/user-by-username/${blackPlayer}`);
                    if (response.ok) {
                        const user = await response.json();
                        blackPfp = user.profile_pic || blackPfp;
                    }
                } catch (e) {
                    console.log('Could not fetch black player pfp');
                }
            }
            
            if (whitePlayer) {
                document.getElementById('whitePlayerInfo').innerHTML = `
                    <div class="player-card">
                        <img class="profile-pic" src="${whitePfp}" alt="White" onerror="this.src='/uploads/default-avatar.png'">
                        <div class="player-details">
                            <h3>‚ö™ ${whitePlayer}</h3>
                            <p>Putih</p>
                        </div>
                    </div>
                `;
            }

            if (blackPlayer) {
                document.getElementById('blackPlayerInfo').innerHTML = `
                    <div class="player-card">
                        <img class="profile-pic" src="${blackPfp}" alt="Black" onerror="this.src='/uploads/default-avatar.png'">
                        <div class="player-details">
                            <h3>‚ö´ ${blackPlayer}</h3>
                            <p>Hitam</p>
                        </div>
                    </div>
                `;
            }
        }

        function updateTurnIndicator(gameData) {
            if (!gameData || typeof gameData.turn === 'undefined') {
                // If no turn info, show waiting state
                document.getElementById('turnIndicator').innerHTML = `Menunggu pemain...`;
                return;
            }

            const turn = gameData.turn === 'w' ? 'Putih' : 'Hitam';
            const isMyTurn = (gameData.turn === 'w' && playerColor === 'white') ||
                            (gameData.turn === 'b' && playerColor === 'black');
            
            document.getElementById('turnIndicator').innerHTML = 
                `Giliran: ${turn} ${isMyTurn ? '(Anda)' : ''}`;
        }

        function displayGameResult(payload) {
            // Prevent showing the same result twice
            if (gameResultShown) {
                return;
            }
            gameResultShown = true;

            const resultDiv = document.getElementById('gameResult');
            let message = '';

            if (payload.result === 'draw') {
                message = 'ü§ù Seri!';
            } else {
                const winnerColor = payload.winner === 'white' ? 'Putih' : 'Hitam';
                const didIWin = payload.winner === playerColor;
                message = didIWin ? `üéâ Anda Menang! (${winnerColor})` : `üò¢ Anda Kalah (${winnerColor} Menang)`;
            }

            resultDiv.textContent = message;
            resultDiv.classList.remove('hidden');
            
            // Show game over overlay if not already shown
            if (!document.getElementById('gameOverOverlay')) {
                showGameOverNotification(message);
            }
            
            loadMyStats();
        }

        function requestRematch() {
            // Remove overlay
            const overlay = document.getElementById('gameOverOverlay');
            if (overlay) overlay.remove();
            
            // Hide result
            document.getElementById('gameResult').classList.add('hidden');
            
            ws.send(JSON.stringify({type: 'rematch'}));
        }

        function offerDraw() {
            if (game.game_over()) {
                showCheckNotification('‚ö†Ô∏è Permainan sudah selesai');
                return;
            }

            ws.send(JSON.stringify({
                type: 'offerDraw',
                payload: {
                    from: currentUser.username
                }
            }));

            showCheckNotification('‚öñÔ∏è Penawaran seri dikirim...');
        }

        function forfeitGame() {
            if (game.game_over()) {
                showCheckNotification('‚ö†Ô∏è Permainan sudah selesai');
                return;
            }

            const confirmed = confirm('Apakah anda yakin ingin menyerah?');
            if (!confirmed) return;

            const winner = playerColor === 'white' ? 'black' : 'white';
            
            ws.send(JSON.stringify({
                type: 'forfeit',
                payload: {
                    winner: winner,
                    result: winner,
                    forfeitor: currentUser.username
                }
            }));

            showCheckNotification('üö© Anda telah menyerah');
        }

        function resetGame(gameData) {
            // Remove any overlays
            const overlay = document.getElementById('gameOverOverlay');
            if (overlay) overlay.remove();
            
            game = new Chess();
            // If board not initialized (edge case), initialize it; otherwise restart
            if (!board) {
                initBoard();
            } else if (board && typeof board.start === 'function') {
                board.start();
            }
            gameOverReported = false;
            gameResultShown = false;
            
            // Swap colors for rematch
            if (gameData.white_player === currentUser.username) {
                playerColor = 'white';
            } else if (gameData.black_player === currentUser.username) {
                playerColor = 'black';
            }
            
            board.orientation(playerColor === 'white' ? 'white' : 'black');
            
            document.getElementById('gameResult').classList.add('hidden');
            removeHighlights();
            updatePlayerInfo(gameData);
            updateTurnIndicator(gameData);
        }

        function leaveLobby() {
            console.log('Leaving lobby', currentLobby);
            
            // Remove any overlays
            const overlay = document.getElementById('gameOverOverlay');
            if (overlay) overlay.remove();
            
            const promotionOverlay = document.getElementById('promotionOverlay');
            if (promotionOverlay) promotionOverlay.remove();
            
            if (ws) {
                ws.close();
                ws = null;
            }
            
            // Clear all game state
            currentLobby = null;
            board = null;
            game = new Chess();
            playerColor = null;
            gameOverReported = false;
            gameResultShown = false;
            
            // Clear localStorage
            localStorage.removeItem('currentLobby');
            localStorage.setItem('currentScreen', 'lobby');
            
            document.getElementById('gameScreen').classList.add('hidden');
            showLobbyScreen();
        }

        async function loadMyStats() {
            try {
                const response = await fetch(`${API_URL}/user/${currentUser.id}/stats`);
                const stats = await response.json();
                
                // Update currentUser
                currentUser.total_matches = stats.total_matches;
                currentUser.total_wins = stats.total_wins;
                currentUser.total_losses = stats.total_losses;
                currentUser.total_draws = stats.total_draws;
                localStorage.setItem('user', JSON.stringify(currentUser));
                
                document.getElementById('myStats').innerHTML = `
                    <div class="stat-item">
                        <span class="stat-label">Total Match</span>
                        <span class="stat-value">${stats.total_matches}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Menang</span>
                        <span class="stat-value">${stats.total_wins}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Kalah</span>
                        <span class="stat-value">${stats.total_losses}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Seri</span>
                        <span class="stat-value">${stats.total_draws}</span>
                    </div>
                `;
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        // Init
        window.onload = () => {
            const savedUser = localStorage.getItem('user');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                
                // Check if we were in a specific screen
                const currentScreen = localStorage.getItem('currentScreen');
                const savedLobby = localStorage.getItem('currentLobby');
                
                console.log('Restored state:', { currentScreen, savedLobby, user: currentUser.username });
                
                if (currentScreen === 'game' && savedLobby) {
                    // User was in a game, reconnect
                    document.getElementById('authScreen').classList.add('hidden');
                    document.getElementById('lobbyScreen').classList.add('hidden');
                    document.getElementById('profileScreen').classList.add('hidden');
                    currentLobby = parseInt(savedLobby);
                    console.log('Reconnecting to lobby', currentLobby);
                    connectWebSocket(currentLobby);
                    showGameScreen();
                } else if (currentScreen === 'profile') {
                    // User was in profile
                    document.getElementById('authScreen').classList.add('hidden');
                    showProfile();
                } else {
                    // Default to lobby
                    document.getElementById('authScreen').classList.add('hidden');
                    showLobbyScreen();
                }
            } else {
                // No saved user, show auth screen
                document.getElementById('lobbyScreen').classList.add('hidden');
                document.getElementById('profileScreen').classList.add('hidden');
                document.getElementById('gameScreen').classList.add('hidden');
                document.getElementById('authScreen').classList.remove('hidden');
            }
        };

        // Save screen state before unload
        window.addEventListener('beforeunload', () => {
            if (!currentUser) return;
            
            if (document.getElementById('gameScreen').classList.contains('hidden') === false) {
                localStorage.setItem('currentScreen', 'game');
                if (currentLobby) {
                    localStorage.setItem('currentLobby', currentLobby);
                }
            } else if (document.getElementById('profileScreen').classList.contains('hidden') === false) {
                localStorage.setItem('currentScreen', 'profile');
            } else if (document.getElementById('lobbyScreen').classList.contains('hidden') === false) {
                localStorage.setItem('currentScreen', 'lobby');
            }
        });
    </script>
</body>
</html>